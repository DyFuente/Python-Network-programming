一.群聊聊天室(续)
    1.退出功能
        [1]服务端:
            * 接受消息确定消息类型
            * 将用户从字典移除
            * 将退出消息发送给其他人
            * 给该用户发送特殊标志
        [2]客户端:
            * 输入quit表示退出
            * 将退出请求发送给服务端然后结束进程
            * recv 接受服务端信息后退出进程
    2.管理员消息

二.multiprocessing模块创建进程
    1.流程特点
        [1] 需要将子进程执行的时间封装为函数
        [2] 通过模块的process类创建进程对象,关联函数
        [3] 可以通过进程对象设置进程信息及属性
        [4] 通过进程对象调用start启动进程
        [5] 通过进程对象调用join回收进程
    2. 基本接口使用
        [1] Process()
            功能: 创建进程对象
            参数: target 绑定要执行的目标函数
                  args 元组,用于给target函数位置传参
                  kwargs 字典,给target函数键值传参
        [2] p.start() 
            功能: 启动进程
                * 启动进程此时target绑定函数开始执行,该函数作为子进程执行内容,
                    此时进程真正被创建
        [3]p.join([timeout])
            功能: 阻塞等待回收进程
            参数: 超时时间 

            注意: * 使用multiprocessing创建进程同样是子进程复制父进程空间代码段,
                    父子进程运行互不影响
                 * 子进程只运行target绑定的函数部分,其余内容均是父进程执行内容
                 * multiprocessing中父进程往往只用来创建子进程回收子进程,
                    具体事件由子进程完成.
                 * multiprocessing创建的子进程中无法使用标准输入
    3. 进程对象属性
        p.name      进程名称
        p.pid       对应子进程的PID号
        p.is_alive()    查看子进程是否在生命周期
        p.daemon    设置父子进程的退出关系
            * 如果设置为True,则子进程会随父进程的退出而结束
            * 要求必须在start前设置
            * 如果设置成True,通常就不会使用join
    
    4. 自定义进程类
      
        编写流程
            [1] 定义进程类,继承Process
            [2] 编写自己的__init__方法,使用super重新加载父类__init__方法
            [3] 重写Process中的run方法
        使用方法
            [1] 使用自定义类实例化对象
            [2] 通过对象调用start()创建进程自动运行run方法
            [3] 实例对象调用join回收子进程

三.进程池技术
    1. 必要性
        [1] 进程的创建和销毁过程消耗的资源较多
        [2] 当任务量众多,每个任务在很短时间内完成时,
            需要频繁的创建和销毁进程.此时对计算机压力较大
        [3] 进程池技术很好的解决了以上问题
    2. 原理
        创建一定数量的进程来处理事件,事件处理完进程不退出而是继续处理其他事件,
        直到所有事件全部处理完毕统一销毁,增加进程的重复利用,降低资源消耗.
    
    3.进程池实现
        [1] 创建进程池对象,放入适当的进程
            from multiprocessing import Pool

            Pool(process)
                功能: 创建进程池对象
                参数: 指定进程数量,默认根据系统自动判定
        [2] 将事件加入进程池队列执行
            pool.apply_async(func,args,kwds)
                功能: 使用进程池执行func事件
                参数: func 事件函数
                    args 元组,给func传参
                    kwds 字典,给func传参
                返回值: 返回函数事件对象
        [3] 关闭进程池
            pool.close()
                功能: 关闭进程池
        [4] 回收进程池中的进程
            pool.join()
                功能: 回收进程池中的进程
        [5] 通过map添加进程池事件
            pool.map(func,iter)
                功能: 将要做的事件加入进程池
                参数: func 事件函数
                     iter 迭代对象,将迭代值传给func
                返回值: 返回函数返回值列表

四.进程间通信(IPC)
    1. 必要性: 进程间空间独立,资源不共享,此时在需要进程间传输时就需要
            特定的手段进行数据通信.
    2. 进程间通信方法: 
        管道 消息队列 共享内存 信号 信号量 套接字
    3. 管道通信(Pipe)
        [1] 通信原理: 在内存中开辟管道空间,生成管道操作对象,多个进程使用同一个管道
                    对象进行读写即可实现通信
        [2] 实现方法: 
            from multiprocessing import Pipe
            fd1,fd2 = Pipe(duplex = True)
                功能: 创建管道
                参数: 默认表示双向管道
                     如果为False表示单向管道
                返回值: 表示管道两端的读写对象
                        如果时双向管道均可读写
                        如果是单向管道,fd1只读,fd2只写
                
            fd.recv()
                功能: 从管道获取内容
                返回值: 获取到的数据
            fd.send(data)
                功能: 向管道写入内容
                参数: 要写入的数据

    4.消息队列
        [1] 通信原理:在内存中建立队列模型,进程通过队列将消息存入,
            或者从队列取出完成进程间通信.
        [2] 实现方法
            from multiprocessing import Queue
            q = Queur(maxsize=0)
                功能: 创建队列对象
                参数: maxsize 最多存放消息个数
                返回值: 队列对象
            
            q.put(data,[block,timeout])
                功能: 向队列存入消息
                参数: data 要存入的内容
                     block 设置是否阻塞,False为非阻塞
                     timeout 超时检测
                    
            q.get([block,timeout])
                功能: 从队列取出消息
                参数: block 设置是否阻塞 False为非阻塞
                     timeout 超时检测
                返回值: 返回获取到的内容
            
            q.full() 判断队列是否为满
            q.empty() 判断队列是否为空
            q.qsize() 判断队列中消息个数
            q.close() 关闭队列
